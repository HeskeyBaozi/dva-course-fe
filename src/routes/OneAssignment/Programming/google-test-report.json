{
  "grade": 60,
  "report": {
    "google tests": {
      "grade": 40,
      "continue": true,
      "google tests": [
        {
          "gtest": {
            "info": {
              "ListMeeting": "List meetings sponsored or participated by a user",
              "MeetingQuery": "Query meetings",
              "CreateMeeting": "Create meeting without time overlap",
              "PureUserOperations": "Register, login, list all users and delete users without operations on meeting",
              "CreateMeetingDateIssues": "Create meeting with time overlap"
            },
            "grade": 40,
            "failure": [
              {
                "CreateMeetingDateIssues": 20
              },
              {
                "MeetingQuery": 20
              }
            ]
          }
        }
      ]
    },
    "compile check": {
      "grade": 20,
      "continue": true,
      "compile check": "pass"
    }
  },
  "answers": [
    {
      "name": "AgendaService.cpp",
      "code": "#include \"AgendaService.hpp\"\n#include  <iostream>\nusing namespace std;\n\nbool nameIsInList(const string name, const vector<string>& nameList)\n{\n\tfor(const string& str : nameList)\n\t{\n\t\tif(str == name)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n// constructor\nAgendaService::AgendaService()\n{\n\tthis->startAgenda();\n}\n\n// desctructor\nAgendaService::~AgendaService()\n{\n\tthis->quitAgenda();\n}\n\n// User related\nbool AgendaService::userLogIn(const std::string userName, \n\t\t\t\t\t\t\t  const std::string password)\n{\n\tauto queryResult = m_storage->queryUser([&](const User& u){\n\t\treturn u.getName() == userName && u.getPassword() == password;\n\t});\n\n\tif(queryResult.size() == 1)\n\t\treturn true;\n\treturn false;\n}\n\nbool AgendaService::userRegister(const std::string userName, \n\t\t\t\t  \t\t\t\t const std::string password,\n                  \t\t\t\t const std::string email, \n                  \t\t\t\t const std::string phone)\n{\n\tauto shouldBeEmpty = m_storage->queryUser([&](const User& u){\n\t\treturn u.getName() == userName;\n\t});\n\n\tif(!shouldBeEmpty.empty())\n\t\treturn false;\n\n\tUser temp(userName, password, email, phone);\n\tm_storage->createUser(temp);\n\treturn true;\n}\n\nbool AgendaService::deleteUser(const std::string userName, \n\t\t\t    \t\t\t   const std::string password)\n{\n\tint count = m_storage->deleteUser([&](const User& u){\n\t\treturn u.getName() == userName && u.getPassword() == password;\n\t});\n\n\tif(count)\n\t{\n\t\tm_storage->deleteMeeting([&](const Meeting& meeting){\n\t\t\tbool sponsorMatched = meeting.getSponsor() == userName;\n\t\t\tbool participatorMatched = nameIsInList(userName, meeting.getParticipator());\n\t\t\treturn sponsorMatched || participatorMatched;\n\t\t});\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstd::list<User> AgendaService::listAllUsers(void) const\n{\n\treturn m_storage->queryUser([](const User& u){\n\t\treturn true;\n\t});\n}\n\n// Meeting realted\nbool AgendaService::createMeeting(const std::string userName, \n\t\t\t\t\t\t\t\t  const std::string title,\n                                  const std::string startDate, \n                                  const std::string endDate,\n                                  const std::vector<std::string> participator)\n{\n\tDate start(startDate);\n\tDate end(endDate);\n\tbool dateIsValid = Date::isValid(start) && Date::isValid(end) && start < end;\n\t\n\tbool sponsorExist = !m_storage->queryUser([&](const User& u){\n\t\treturn u.getName() == userName;\n\t}).empty();\n\tbool participatorExist = true;\n\tfor(const string& name : participator)\n\t{\n\t\tif(m_storage->queryUser([&](const User& u){\n\t\t\treturn u.getName() == name;\n\t\t}).empty())\n\t\t{\n\t\t\tparticipatorExist = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbool participatorNoP = true;\n\tfor(int t1 = 0; t1 != participator.size(); ++t1)\n\t{\n\t\tfor(int t2 = 0; t2 != participator.size(); ++t2)\n\t\t{\n\t\t\tif(participator[t1] == participator[t2] && t1 != t2)\n\t\t\t{\n\t\t\t\tparticipatorNoP = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(participatorNoP == false)\n\t\t\tbreak;\n\t}\n\n\tbool everyExist = sponsorExist && participatorExist && participatorNoP;\n\t\n\tbool sponsorNotInPart = !nameIsInList(userName, participator);\n\t\n\tbool titleDistinct = m_storage->queryMeeting([&](const Meeting& meeting){\n\t\treturn meeting.getTitle() == title;\n\t}).empty();\n\t\n\n\tbool sponsorTimeOK = m_storage->queryMeeting([&](const Meeting& meeting){\n\t\tbool isSponsor = meeting.getSponsor() == userName;\n\t\tbool timeOK = !(end <= meeting.getStartDate() || meeting.getEndDate() <= start);\n\t\treturn isSponsor && timeOK;\n\t}).empty();\n\n\tbool participatorTimeOK = true;\n\tfor(const string& name: participator)\n\t{\n\t\tif(!m_storage->queryMeeting([&](const Meeting& meeting){\n\t\t\t\tbool getPart = meeting.getSponsor() == name || nameIsInList(name, meeting.getParticipator());\n\t\t\t\tbool timeOK = !(end <= meeting.getStartDate() || meeting.getEndDate() <= start);\n\t\t\t\t\treturn getPart && timeOK;\n\t\t\t}).empty())\n\t\t{\n\t\t\tparticipatorTimeOK = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool everyTimeOk = sponsorTimeOK && participatorTimeOK;\n\n\tif(dateIsValid && everyExist && sponsorNotInPart\n\t\t&& titleDistinct && everyTimeOk)\n\t{\n\t\tMeeting temp(userName, participator, start, end, title);\n\t\tm_storage->createMeeting(temp);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\nstd::list<Meeting> AgendaService::meetingQuery(const std::string userName,\n                                    \t\t   const std::string title) const\n{\n\treturn m_storage->queryMeeting([&](const Meeting& mt){\n\t\tbool titleMatched = title == mt.getTitle();\n\t\tbool sponsorMatched = userName == mt.getSponsor();\n\t\tbool participatorMatched = nameIsInList(userName, mt.getParticipator());\n\t\treturn titleMatched && (sponsorMatched || participatorMatched);\n\t});\n}\n\nstd::list<Meeting> AgendaService::meetingQuery(const std::string userName,\n                               \t\t\t\t   const std::string startDate,\n                                \t\t\t   const std::string endDate) const\n{\n\tDate qStart(startDate);\n\tDate qEnd(endDate);\n\tbool dateIsValid = Date::isValid(qStart) && Date::isValid(qEnd);\n\tif(!dateIsValid) return list<Meeting>();\n\n\treturn m_storage->queryMeeting([&](const Meeting& mt){\n\t\tbool timeMatched = qStart <= mt.getStartDate() && mt.getStartDate() <= qEnd\n\t\t\t\t\t\t\t|| qStart <= mt.getEndDate() && mt.getEndDate() <= qEnd\n\t\t\t\t\t\t\t|| mt.getStartDate() <= qStart && qStart <= mt.getEndDate()\n\t\t\t\t\t\t\t|| mt.getStartDate() <= qEnd && qEnd <= mt.getEndDate();\n\t\tbool sponsorMatched = userName == mt.getSponsor();\n\t\tbool participatorMatched = nameIsInList(userName, mt.getParticipator());\n\t\treturn  timeMatched && (sponsorMatched || participatorMatched);\n\t});\n}\n\nstd::list<Meeting> AgendaService::listAllMeetings(const std::string userName) const\n{\n\treturn m_storage->queryMeeting([&](const Meeting& mt){\n\t\tbool sponsorMatched = userName == mt.getSponsor();\n\t\tbool participatorMatched = nameIsInList(userName, mt.getParticipator());\n\t\treturn sponsorMatched || participatorMatched;\n\t});\n}\n\nstd::list<Meeting> AgendaService::listAllSponsorMeetings(const std::string userName) const\n{\n\treturn m_storage->queryMeeting([&](const Meeting& mt){\n\t\treturn userName == mt.getSponsor();\n\t});\n}\n\nstd::list<Meeting> AgendaService::listAllParticipateMeetings(const std::string userName) const\n{\n\treturn m_storage->queryMeeting([&](const Meeting& mt){\n\t\treturn nameIsInList(userName, mt.getParticipator()) && userName != mt.getSponsor();\n\t});\n}\n\nbool AgendaService::deleteMeeting(const std::string userName, \n\t\t\t\t\t\t\t\t  const std::string title)\n{\n\tint count = m_storage->deleteMeeting([&](const Meeting& meeting){\n\t\treturn meeting.getSponsor() == userName && meeting.getTitle() == title;\n\t});\n\tif(count)\n\t\treturn true;\n\treturn false;\n}\n\nbool AgendaService::deleteAllMeetings(const std::string userName)\n{\n\tint count = m_storage->deleteMeeting([&](const Meeting& meeting){\n\t\treturn meeting.getSponsor() == userName;\n\t});\n\tif(count)\n\t\treturn true;\n\treturn false;\n}\n\n// system related\nvoid AgendaService::startAgenda(void)\n{\n\tm_storage = Storage::getInstance();\n}\n\nvoid AgendaService::quitAgenda(void)\n{\n\tm_storage = nullptr;\n}"
    },
    {
      "name": "Storage.cpp",
      "code": "#include \"Storage.hpp\"\n#include \"Path.hpp\"\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\nstd::shared_ptr<Storage> Storage::m_instance = nullptr;\n\n// constructor\nStorage::Storage()\n{\n\treadFromFile();\n\tthis->m_dirty = false;\n}\n\n// destructor\nStorage::~Storage()\n{\n\tif(this->m_dirty)\n\t\tthis->sync();\n\tm_instance = nullptr;\n}\n\n// singla Partten\nstd::shared_ptr<Storage> Storage::getInstance(void)\n{\n\tif(m_instance == nullptr)\n\t{\n\t\tm_instance = shared_ptr<Storage>(new Storage());\n\t}\n\treturn m_instance;\n}\n\n// creator\nvoid Storage::createUser(const User & t_user)\n{\n\tthis->m_userList.push_back(t_user);\n\tthis->m_dirty = true;\n}\n\nvoid Storage::createMeeting(const Meeting & t_meeting)\n{\n\tthis->m_meetingList.push_back(t_meeting);\n\tthis->m_dirty = true;\n}\n\n// query\nstd::list<User> Storage::queryUser(std::function<bool(const User &)> filter) const\n{\n\tlist<User> queryResult;\n\tfor(const User& user : this->m_userList)\n\t{\n\t\tif(filter(user))\n\t\t{\n\t\t\tqueryResult.push_back(user);\n\t\t}\n\t}\n\treturn queryResult;\n}\n\nstd::list<Meeting> Storage::queryMeeting(std::function<bool(const Meeting &)> filter) const\n{\n\tlist<Meeting> queryResult;\n\tfor(const Meeting& meeting : this->m_meetingList)\n\t{\n\t\tif(filter(meeting))\n\t\t{\n\t\t\tqueryResult.push_back(meeting);\n\t\t}\n\t}\n\treturn queryResult;\n}\n\n// updator\nint Storage::updateUser(std::function<bool(const User &)> filter,\n                 std::function<void(User &)> switcher)\n{\n\tint count = 0;\n\tfor(User& user: this->m_userList)\n\t{\n\t\tif(filter(user))\n\t\t{\n\t\t\tcount++;\n\t\t\tswitcher(user);\n\t\t}\n\t}\n\tif(count != 0)\n\t\tthis->m_dirty = true;\n\treturn count;\n}\n\nint Storage::updateMeeting(std::function<bool(const Meeting &)> filter,\n                    std::function<void(Meeting &)> switcher)\n{\n\tint count = 0;\n\tfor(Meeting& meeting: this->m_meetingList)\n\t{\n\t\tif(filter(meeting))\n\t\t{\n\t\t\tcount++;\n\t\t\tswitcher(meeting);\n\t\t}\n\t}\n\tif(count != 0)\n\t\tthis->m_dirty = true;\n\treturn count;\t\n}\n\n// deletor\nint Storage::deleteUser(std::function<bool(const User &)> filter)\n{\n\tint count = 0;\n\tfor(auto it = this->m_userList.begin();\n\t\tit != this->m_userList.end();\n\t\t++it)\n\t{\n\t\tif(filter(*it))\n\t\t{\n\t\t\tit = this->m_userList.erase(it);\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(count != 0)\n\t\tthis->m_dirty = true;\n\treturn count;\n}\n\nint Storage::deleteMeeting(std::function<bool(const Meeting &)> filter)\n{\n\tint count = 0;\n\tfor(auto it = this->m_meetingList.begin();\n\t\tit != this->m_meetingList.end();\n\t\t++it)\n\t{\n\t\tif(filter(*it))\n\t\t{\n\t\t\tit = this->m_meetingList.erase(it);\n\t\t\t--it;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(count != 0)\n\t\tthis->m_dirty = true;\n\treturn count;\n}\n\n// IO\nbool Storage::writeToFile(void)\n{\n\tofstream fout;\n\tfout.open(Path::userPath);\n\tif(fout)\n\t{\n\t\tfor(const User& user : this->m_userList)\n\t\t{\n\t\t\tfout << \"\\\"\" << user.getName() << \"\\\",\\\"\" \n\t\t\t\t << user.getPassword() << \"\\\",\\\"\" \n\t\t\t\t << user.getEmail() << \"\\\",\\\"\" \n\t\t\t\t << user.getPhone() << \"\\\"\" << endl;\n\t\t}\n\t} \n\tfout.close();\n\n\tfout.open(Path::meetingPath);\n\tif(fout)\n\t{\n\t\tfor(const Meeting& meeting : this->m_meetingList)\n\t\t{\n\t\t\tstring participatorStr;\n\t\t\tfor(const string& pNameStr : meeting.getParticipator())\n\t\t\t{\n\t\t\t\tparticipatorStr += pNameStr + '&';\n\t\t\t}\n\t\t\tparticipatorStr.pop_back();\n\n\t\t\tfout << \"\\\"\" << meeting.getSponsor() << \"\\\",\\\"\" \n\t\t\t<< participatorStr << string(\"\\\",\\\"\") \n\t\t\t<< Date::dateToString(meeting.getStartDate()) << \"\\\",\\\"\" \n\t\t\t<< Date::dateToString(meeting.getEndDate()) << \"\\\",\\\"\" \n\t\t\t<< meeting.getTitle() << \"\\\"\" << endl;\n\t\t}\n\t} else\n\t\treturn false;\n\tfout.close();\n\treturn true;\n}\n\n// my read\n\nstd::vector<string> readLine(const string& line)\n{\n\tvector<string> result;\n\tstring temp;\n\tbool in = false;\n\n\tfor(const char& c : line)\n\t{\n\t\tif(c == '\\\"')\n\t\t{\n\t\t\tif(!in)\n\t\t\t{\n\t\t\t\tin = true;\n\t\t\t\ttemp = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin = false;\n\t\t\t\tresult.push_back(temp);\n\t\t\t}\n\t\t}\n\t\tif(in && c != '\\\"')\n\t\t{\n\t\t\ttemp += c;\n\t\t}\n\t}\n\treturn result;\n}\n\nstd::vector<string> readPart(const string& pStr)\n{\n\tvector<string> result;\n\tstring temp;\n\tfor(auto it = pStr.begin(); it != pStr.end(); ++it)\n\t{\n\t\tif(*it == '&')\n\t\t{\n\t\t\tresult.push_back(temp);\n\t\t\ttemp = \"\";\n\t\t}\n\t\telse\n\t\t\ttemp += *it;\n\t\tif(it + 1 == pStr.end())\n\t\t{\n\t\t\tresult.push_back(temp);\n\t\t}\n\t}\n\treturn result;\n}\n\nbool Storage::readFromFile(void)\n{\n\n\tifstream fin;\n\tfin.open(Path::userPath);\n\tif(fin)\n\t{\n\t\twhile(!fin.eof())\n\t\t{\n\t\t\tstring line;\n\t\t\tgetline(fin, line);\n\t\t\tstd::vector<string> result = readLine(line);\n\t\t\tif(result.size() == 4)\n\t\t\t{\n\t\t\t\tUser temp(result[0],result[1],result[2],result[3]);\n\t\t\t\tm_userList.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\tfin.close();\n\n\tfin.open(Path::meetingPath);\n\tif(fin)\n\t{\n\t\twhile(!fin.eof())\n\t\t{\n\t\t\tstring line;\n\t\t\tgetline(fin, line);\n\t\t\tstd::vector<string> result = readLine(line);\n\t\t\tif(result.size() == 5)\n\t\t\t{\n\t\t\t\tvector<string> participator = readPart(result[1]);\n\t\t\t\tMeeting temp(result[0], participator, Date(result[2]), Date(result[3]), result[4]);\n\t\t\t\tm_meetingList.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn false;\n\tfin.close();\n\treturn true;\n}\n\n// sync\nbool Storage::sync(void)\n{\n\treturn writeToFile();\n}"
    },
    {
      "name": "Meeting.cpp",
      "code": "#include \"Meeting.hpp\"\n#include <algorithm>\nusing namespace std;\n\n// constructor\n\nMeeting::Meeting(std::string t_sponsor, \n          \t\tstd::vector<std::string> t_participator, \n         \t\tDate t_startTime,\n          \t\tDate t_endTime, \n          \t\tstd::string t_title)\n{\n\tthis->setSponsor(t_sponsor);\n\tthis->setParticipator(t_participator);\n\tthis->setStartDate(t_startTime);\n\tthis->setEndDate(t_endTime);\n\tthis->setTitle(t_title);\n}\n\n\nMeeting::Meeting(const Meeting &t_meeting)\n{\n\tthis->setSponsor(t_meeting.getSponsor());\n\tthis->setParticipator(t_meeting.getParticipator());\n\tthis->setStartDate(t_meeting.getStartDate());\n\tthis->setEndDate(t_meeting.getEndDate());\n\tthis->setTitle(t_meeting.getTitle());\n}\n\n\n// getter\n\nstd::string Meeting::getSponsor(void) const\n{\n\treturn m_sponsor;\n}\n\nstd::vector<std::string> Meeting::getParticipator(void) const\n{\n\treturn m_participators;\n}\n\nDate Meeting::getStartDate(void) const\n{\n\treturn m_startDate;\n}\n\nDate Meeting::getEndDate(void) const\n{\n\treturn m_endDate;\n}\n\nstd::string Meeting::getTitle(void) const\n{\n\treturn m_title;\n}\n\n\n// setter\n\nvoid Meeting::setSponsor(const std::string t_sponsor)\n{\n\tm_sponsor = t_sponsor;\n}\n\nvoid Meeting::setParticipator(const std::vector<std::string> t_participators)\n{\n\tm_participators = t_participators;\n}\n\nvoid Meeting::setStartDate(const Date t_startTime)\n{\n\tm_startDate = t_startTime;\n}\n\nvoid Meeting::setEndDate(const Date t_endTime)\n{\n\tm_endDate = t_endTime;\n}\n\nvoid Meeting::setTitle(const std::string t_title)\n{\n\tm_title = t_title;\n}\n\n// Judge\n\nbool Meeting::isParticipator(const std::string t_username) const\n{\n\tbool found = false;\n\tfor(const string& name : m_participators)\n\t{\n\t\tif(name == t_username)\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
    },
    {
      "name": "User.cpp",
      "code": "#include \"User.hpp\"\nusing namespace std;\n\nUser::User(std::string t_userName, \n\t\t   std::string t_userPassword,\n           std::string t_userEmail, \n           std::string t_userPhone)\n{\n\tsetName(t_userName);\n\tsetPassword(t_userPassword);\n\tsetEmail(t_userEmail);\n\tsetPhone(t_userPhone);\n}\n\nUser::User(const User &t_user)\n{\n\tsetName(t_user.getName());\n\tsetPassword(t_user.getPassword());\n\tsetEmail(t_user.getEmail());\n\tsetPhone(t_user.getPhone());\n}\n\n// getter\n\nstd::string User::getName() const\n{\n\treturn m_name;\n}\n\nstd::string User::getPassword() const\n{\n\treturn m_password;\n}\n\nstd::string User::getEmail() const\n{\n\treturn m_email;\n}\n\nstd::string User::getPhone() const\n{\n\treturn m_phone;\n}\n\n// setter\n\nvoid User::setName(std::string t_name)\n{\n\tm_name = t_name;\n}\n\nvoid User::setPassword(std::string t_password)\n{\n\tm_password = t_password;\n}\n\nvoid User::setEmail(std::string t_email)\n{\n\tm_email = t_email;\n}\n\nvoid User::setPhone(std::string t_phone)\n{\n\tm_phone = t_phone;\n}"
    },
    {
      "name": "Date.cpp",
      "code": "#include \"Date.hpp\"\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\n// constructor\nDate::Date()\n{\n\tthis->setYear(0);\n\tthis->setMonth(0);\n\tthis->setDay(0);\n\tthis->setHour(0);\n\tthis->setMinute(0);\n}\n\nDate::Date(int t_year, int t_month, int t_day, int t_hour, int t_minute)\n{\n\tthis->setYear(t_year);\n\tthis->setMonth(t_month);\n\tthis->setDay(t_day);\n\tthis->setHour(t_hour);\n\tthis->setMinute(t_minute);\n}\n\nDate::Date(std::string dateString)\n{\n\t*this = Date::stringToDate(dateString);\n}\n\n// getter\n\nint Date::getYear(void) const\n{\n\treturn m_year;\n}\n\nint Date::getMonth(void) const\n{\n\treturn m_month;\n}\n\nint Date::getDay(void) const\n{\n\treturn m_day;\n}\n\nint Date::getHour(void) const\n{\n\treturn m_hour;\n}\n\nint Date::getMinute(void) const\n{\n\treturn m_minute;\n}\n\n// setter\n\nvoid Date::setYear(const int t_year)\n{\n\tm_year = t_year;\n}\n\nvoid Date::setMonth(const int t_month)\n{\n\tm_month = t_month;\n}\n\nvoid Date::setDay(const int t_day)\n{\n\tm_day = t_day;\n}\n\nvoid Date::setHour(const int t_hour)\n{\n\tm_hour = t_hour;\n}\n\nvoid Date::setMinute(const int t_minute)\n{\n\tm_minute = t_minute;\n}\n\n// String\n\nDate Date::stringToDate(const std::string t_dateString)\n{\n\tint m_year = 0;\n\tint m_month = 0;\n\tint m_day = 0;\n\tint m_hour = 0;\n\tint m_minute = 0;\n\tint success = sscanf(t_dateString.c_str(), \"%04d-%02d-%02d/%02d:%02d\",\n\t\t&m_year, &m_month, &m_day,\n\t\t&m_hour, &m_minute);\n\n\tDate result(m_year, m_month, m_day, m_hour, m_minute);\n\tif(t_dateString.length() == 16 && success == 5)\n\t\treturn result;\n\treturn Date(0,0,0,0,0);\n}\n\nstd::string Date::dateToString(Date t_date)\n{\n\tif(Date::isValid(t_date))\n\t{\n\t\tchar charStr[50];\n\t\tsprintf(charStr, \"%04d-%02d-%02d/%02d:%02d\",\n\t\t\tt_date.getYear(),\n\t\t\tt_date.getMonth(),\n\t\t\tt_date.getDay(),\n\t\t\tt_date.getHour(),\n\t\t\tt_date.getMinute());\n\t\treturn string(charStr);\n\t} else {\n\t\treturn \"0000-00-00/00:00\";\n\t}\n}\n\nbool isLeapYear(const int year)\n{\n\treturn year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);\n}\n\nbool Date::isValid(const Date t_date)\n{\n\tbool yearIsValid = t_date.getYear() >= 1000 && t_date.getYear() <= 9999;\n\t\n\tint daysInMonth[13] = {\n\t\t0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\t};\n\t\n\tif(isLeapYear(t_date.getYear()))\n\t{\n\t\tdaysInMonth[2] = 29;\n\t}\n\n\tbool monthIsValid = t_date.getMonth() >= 1 && t_date.getMonth() <= 12;\n\tbool dayIsValid = t_date.getDay() >= 1 && t_date.getDay() <= daysInMonth[t_date.getMonth()];\n\tbool hourIsValid = t_date.getHour() >= 0 && t_date.getHour() <= 23;\n\tbool minuteIsValid = t_date.getMinute() >= 0 && t_date.getMinute() <= 59;\n\n\treturn yearIsValid && monthIsValid && dayIsValid && hourIsValid && minuteIsValid;\n}\n\n// operator\n\nDate& Date::operator=(const Date &t_date)\n{\n\tthis->setYear(t_date.getYear());\n\tthis->setMonth(t_date.getMonth());\n\tthis->setDay(t_date.getDay());\n\tthis->setHour(t_date.getHour());\n\tthis->setMinute(t_date.getMinute());\n\treturn *this;\n}\n\nbool Date::operator==(const Date &t_date) const\n{\n\tbool Year = this->getYear() == t_date.getYear();\n\tbool Month = this->getMonth() == t_date.getMonth();\n\tbool Day = this->getDay() == t_date.getDay();\n\tbool Hour = this->getHour() == t_date.getHour();\n\tbool Minute = this->getMinute() == t_date.getMinute();\n\treturn Year && Month && Day && Hour && Minute;\n}\n\nbool Date::operator<(const Date &t_date) const\n{\n\tif(this->getYear() < t_date.getYear())\n\t\treturn true;\n\telse if(this->getYear() == t_date.getYear())\n\t{\n\t\tif(this->getMonth() < t_date.getMonth())\n\t\t\treturn true;\n\t\telse if(this->getMonth() == t_date.getMonth())\n\t\t{\n\t\t\tif(this->getDay() < t_date.getDay())\n\t\t\t\treturn true;\n\t\t\telse if(this->getDay() == t_date.getDay())\n\t\t\t{\n\t\t\t\tif(this->getHour() < t_date.getHour())\n\t\t\t\t\treturn true;\n\t\t\t\telse if(this->getHour() == t_date.getHour())\n\t\t\t\t{\n\t\t\t\t\tif(this->getMinute() < t_date.getMinute())\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool Date::operator<=(const Date &t_date) const\n{\n\treturn *this < t_date || *this == t_date;\n}\n\nbool Date::operator>(const Date &t_date) const\n{\n\treturn !(*this <= t_date);\n}\n\nbool Date::operator>=(const Date &t_date) const\n{\n\treturn !(*this < t_date);\n}"
    }
  ],
  "sub_ca_id": 7126
}
